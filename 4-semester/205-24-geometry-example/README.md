# geometry

Алгоритмы на вычислительную геометрию.

## О стиле написания кода

Данная задача предназначена для того, чтобы смоделировать работу в реальной конторе или коллективе. Как правило, в приличных фирмах и сообществах принят единый стиль написания кода. Никто не станет добавлять Ваш код, если он написан так, что только Вы его понимаете. Поэтому, выполняя это задание, предстватьте, что Вы его делаете не для того, чтобы получить зачёт, а для того, чтобы сделать что-либо полезное, чем в дальнейшем смогут пользоваться другие люди.

Я предлагаю использовать что-то вроде [стиля написания кода от Google](https://google.github.io/styleguide/cppguide.html). У них есть специальная программа [cpplint](https://github.com/cpplint/cpplint), которая выдаёт предупреждения, когда видит нарушение стиля.

Приведу несколько примеров для тех, кому лень читать *google cpp style guide*.

**Длина каждой строчки не более 80 символов.** Это удобно, например, в тех случаях, когда требуется распечатать кусок кода.

**Размер одного отступа --- 2 пробела. Табуляции не используем.** Дело в том, что табуляция в разных текстовых редакторах представляется по-разному, поэтому при открытии в другом редакторе весь код может "поехать". В настоящее время практически любой текстовый редактор позволяет включить опцию "заменять табуляции пробелами". Поэтому данное требование не должно вызвать каких-либо проблем.

```c++
//  Типы данных называем осмысленными словами camel case'ом с большой буквы.
class CamelCase { //  Открывающаяся скобка там же, где объявление.
 //  Модификатор доступа на один пробел правее имени класса.
 private:
  //  Переменные camel case'ом с маленькой буквы (также осмысленными словами).
  double camelCaseVariable;

  void CamelCaseMethod() {
  }
 public:
  CamelCase() {
  }
};
```

Бинарные операторы рекомендуется отделять пробелами:
```c++
a = b + c;
c += d;
```

После `if`, `for`, `while` ставится пробел:
```c++
for (int i = 0; i < n; i++) {
}
```

## Детали выполнения задания

1. Добавляем в папку `include` файл `my_algorithm_name.hpp` (замените на название Вашего алгоритма snake case'ом). Реализовать в этом файле шаблонный алгоритм.
2. Добавить в папку `methods` файл `my_algorithm_name_method.cpp` (замените на название Вашего алгоритма snake case'ом).
3. Добавить в папку `tests` файл `my_algorithm_name_test.cpp` (замените на название Вашего алгоритма snake case'ом).
4. Созданные файлы нужно прописать в файл `CMakeLists.txt` **в алфавитном порядке**.
5. Реализовать в файле для метода серверную часть алгоритма, которая принимает на вход JSON, запускает алгоритм и записывает результат в выходной JSON. Метод должен запускаться одной функцией с прототипом `int MyAlgorithmNameMethod(const nlohmann::json& input, nlohmann::json* output)` (замените на название Вашего алгоритма camel case'ом). Прототип этой функции следует положить в файл `methods/methods.hpp`. Функция должна запускаться в обработчике на `POST` запрос `/MyAlgorithmName` (замените на название Вашего алгоритма camel case'ом), который нужно добавить в функцию `main()` в файле `methods/main.cpp`.
6. Реализовать набор тестов в созданном Вами файле для тестов. Он должен вызываться одной функцией с прототипом `void TestMyAlgorithmName()` (замените на название Вашего алгоритма camel case'ом), которую следует вызвать в функции `main()` в файле `tests/main.cpp`. Прототип этой функции следует положить в заголовочный файл `tests/test.hpp`. Требуется реализовать несколько статических тестов и хотя бы один тест со случайными значениями.
7. Написать документацию к коду. Добавить описание алгоритма и примеры его использования в файл `doc/algorithms/my_algorithm_name.dox`. Прописать документацию к алгоритму в списке алгоритмов в файле `doc/algorithms.dox`.

**Внимание.**
Для того, чтобы сразу отслеживать ошибки компиляции, а не после того, как уже всё написано, я советую добавить пустые заглушки для алгоритма и тестов. То есть Вы создаёте пустые функции, а реализацию дописываете позже. Добавьте самый простой тест, который просто запускает функцию с алгоритмом, но при этом ничего не проверяет. Это заставит компилятор компилировать шаблонную функцию с алгоритмом.

## Сборка проекта

Для сборки проекта нужно выполнить следующие команды:
```bash
# Создание папки для сборки. Лучше папку не переименовывать,
# поскольку она прописана в .gitignore. В данном примере
# предполагается, что папка build создаётся в корне репозитория.
mkdir build

# Перейти в папку для сборки.
cd build

# Сгенерировать Makefile при помощи cmake. Команде cmake необходимо
# передать путь к корню репозитория. В данном случае он находится на уровень выше.
cmake ../

# Запустить сборку.
make
```

При работе в Jupyter **для удобства разработки рекомендуется использовать компилятор clang** для того, чтобы избежать лишних warning'ов. Для этого нужно запустить `cmake` следующим образом:
```bash
cmake -D CMAKE_CXX_COMPILER=clang++ ../
```
Тем не менее, финальный вариант **должен компилироваться** компилятором `gcc` в Jupyter.

Кроме того, в Jupyter можно использовать `cpplint`. Для этого из корня репозитория нужно запустить следующую команду:
```
cpplint --recursive --filter="-legal/copyright,-build/c++11,-build/c++14" --exclude=*/.ipynb_checkpoints/* methods/ tests/ include/
```

На некоторых системах cmake может сгенерировать файлы для другой системы сборки (не GNU Make). Тогда его нужно
запустить с ключом
```bash
cmake -G "Unix Makefiles" ../
```

Кроме того, могут быть определены следующие переменные, влияющие на сборку:
```bash
# Сгенерировать Makefile с включёнными флагами оптимизации.
cmake -D CMAKE_BUILD_TYPE=Release ../

# Сгенерировать Makefile для сборки проекта с отладочной информацией и без оптимизаций.
cmake -D CMAKE_BUILD_TYPE=Debug ../

# Сгенерировать Makefile для сборки проекта с включёнными предупреждениями компилятора.
# Это рекомендуемый способ, поскольку cmake по-умолчанию генерирует Makefile,
# в котором не все предупреждения включены.
cmake -D CMAKE_CXX_FLAGS="-Wall -Wextra" ../

# Переменные можно комбинировать.
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_CXX_FLAGS="-Wall -Wextra" ../
```

Команде `make` можно передать количество процессов, которые можно запустить одновременно, то есть сколько файлов можно одновременно компилировать. Рекомендуется выставлять `кол-во ядер процессора + 1`.
```
# Собрать проект, используя три процесса.
make -j3
```

## Запуск программы

После сборки программы в папке сборки появятся исполняемые файлы `geometry_server` и  `geometry_test`. Их нужно последовательно запустить в разных терминалах. Сначала сервер, а потом клиент.

```bash
# В первом терминале
./build/geometry_server

# Во втором терминале
./build/geometry_test
```

После успешного выполнения программы-клиента сервер прекращает работу.
